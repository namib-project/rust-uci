/* automatically generated by rust-bindgen 0.58.1 */

pub const UCI_CONFDIR: &'static [u8; 12usize] = b"/etc/config\0";
pub const UCI_SAVEDIR: &'static [u8; 10usize] = b"/tmp/.uci\0";
pub const UCI_DIRMODE: u32 = 448;
pub const UCI_FILEMODE: u32 = 384;
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__jmpbuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__mask_was_saved as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__saved_mask as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
pub type size_t = ::std::os::raw::c_ulong;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub const UCI_OK: ::std::os::raw::c_uint = 0;
pub const UCI_ERR_MEM: ::std::os::raw::c_uint = 1;
pub const UCI_ERR_INVAL: ::std::os::raw::c_uint = 2;
pub const UCI_ERR_NOTFOUND: ::std::os::raw::c_uint = 3;
pub const UCI_ERR_IO: ::std::os::raw::c_uint = 4;
pub const UCI_ERR_PARSE: ::std::os::raw::c_uint = 5;
pub const UCI_ERR_DUPLICATE: ::std::os::raw::c_uint = 6;
pub const UCI_ERR_UNKNOWN: ::std::os::raw::c_uint = 7;
pub const UCI_ERR_LAST: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uci_list {
    pub next: *mut uci_list,
    pub prev: *mut uci_list,
}
#[test]
fn bindgen_test_layout_uci_list() {
    assert_eq!(
        ::std::mem::size_of::<uci_list>(),
        16usize,
        concat!("Size of: ", stringify!(uci_list))
    );
    assert_eq!(
        ::std::mem::align_of::<uci_list>(),
        8usize,
        concat!("Alignment of ", stringify!(uci_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_list>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_list),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_list>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_list),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uci_parse_context {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " uci_alloc_context: Allocate a new uci context"]
    pub fn uci_alloc_context() -> *mut uci_context;
}
extern "C" {
    #[doc = " uci_free_context: Free the uci context including all of its data"]
    pub fn uci_free_context(ctx: *mut uci_context);
}
extern "C" {
    #[doc = " uci_perror: Print the last uci error that occured"]
    #[doc = " @ctx: uci context"]
    #[doc = " @str: string to print before the error message"]
    pub fn uci_perror(ctx: *mut uci_context, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " uci_geterror: Get an error string for the last uci error"]
    #[doc = " @ctx: uci context"]
    #[doc = " @dest: target pointer for the string"]
    #[doc = " @str: prefix for the error message"]
    #[doc = ""]
    #[doc = " Note: string must be freed by the caller"]
    pub fn uci_get_errorstr(
        ctx: *mut uci_context,
        dest: *mut *mut ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " uci_import: Import uci config data from a stream"]
    #[doc = " @ctx: uci context"]
    #[doc = " @stream: file stream to import from"]
    #[doc = " @name: (optional) assume the config has the given name"]
    #[doc = " @package: (optional) store the last parsed config package in this variable"]
    #[doc = " @single: ignore the 'package' keyword and parse everything into a single package"]
    #[doc = ""]
    #[doc = " the name parameter is for config files that don't explicitly use the 'package <...>' keyword"]
    #[doc = " if 'package' points to a non-null struct pointer, enable delta tracking and merge"]
    pub fn uci_import(
        ctx: *mut uci_context,
        stream: *mut FILE,
        name: *const ::std::os::raw::c_char,
        package: *mut *mut uci_package,
        single: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_export: Export one or all uci config packages"]
    #[doc = " @ctx: uci context"]
    #[doc = " @stream: output stream"]
    #[doc = " @package: (optional) uci config package to export"]
    #[doc = " @header: include the package header"]
    pub fn uci_export(
        ctx: *mut uci_context,
        stream: *mut FILE,
        package: *mut uci_package,
        header: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_load: Parse an uci config file and store it in the uci context"]
    #[doc = ""]
    #[doc = " @ctx: uci context"]
    #[doc = " @name: name of the config file (relative to the config directory)"]
    #[doc = " @package: store the loaded config package in this variable"]
    pub fn uci_load(
        ctx: *mut uci_context,
        name: *const ::std::os::raw::c_char,
        package: *mut *mut uci_package,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_unload: Unload a config file from the uci context"]
    #[doc = ""]
    #[doc = " @ctx: uci context"]
    #[doc = " @package: pointer to the uci_package struct"]
    pub fn uci_unload(ctx: *mut uci_context, p: *mut uci_package) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_lookup_ptr: Split an uci tuple string and look up an element tree"]
    #[doc = " @ctx: uci context"]
    #[doc = " @ptr: lookup result struct"]
    #[doc = " @str: uci tuple string to look up"]
    #[doc = " @extended: allow extended syntax lookup"]
    #[doc = ""]
    #[doc = " if extended is set to true, uci_lookup_ptr supports the following"]
    #[doc = " extended syntax:"]
    #[doc = ""]
    #[doc = " Examples:"]
    #[doc = "   network.@interface[0].ifname ('ifname' option of the first interface section)"]
    #[doc = "   network.@interface[-1]       (last interface section)"]
    #[doc = " Note: uci_lookup_ptr will automatically load a config package if necessary"]
    #[doc = " @str must not be constant, as it will be modified and used for the strings inside @ptr,"]
    #[doc = " thus it must also be available as long as @ptr is in use."]
    #[doc = ""]
    #[doc = " This function returns UCI_ERR_NOTFOUND if the package specified in the tuple"]
    #[doc = " string cannot be found.  Otherwise it will return UCI_OK."]
    #[doc = ""]
    #[doc = " Note that failures in looking up other parts, if they are also specfied,"]
    #[doc = " including section and option, will also have a return value UCI_OK but with"]
    #[doc = " ptr->flags * UCI_LOOKUP_COMPLETE not set."]
    pub fn uci_lookup_ptr(
        ctx: *mut uci_context,
        ptr: *mut uci_ptr,
        str_: *mut ::std::os::raw::c_char,
        extended: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_add_section: Add an unnamed section"]
    #[doc = " @ctx: uci context"]
    #[doc = " @p: package to add the section to"]
    #[doc = " @type: section type"]
    #[doc = " @res: pointer to store a reference to the new section in"]
    pub fn uci_add_section(
        ctx: *mut uci_context,
        p: *mut uci_package,
        type_: *const ::std::os::raw::c_char,
        res: *mut *mut uci_section,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_set: Set an element's value; create the element if necessary"]
    #[doc = " @ctx: uci context"]
    #[doc = " @ptr: uci pointer"]
    #[doc = ""]
    #[doc = " The updated/created element is stored in ptr->last"]
    pub fn uci_set(ctx: *mut uci_context, ptr: *mut uci_ptr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_add_list: Append a string to an element list"]
    #[doc = " @ctx: uci context"]
    #[doc = " @ptr: uci pointer (with value)"]
    #[doc = ""]
    #[doc = " Note: if the given option already contains a string value,"]
    #[doc = " it will be converted to an 1-element-list before appending the next element"]
    pub fn uci_add_list(ctx: *mut uci_context, ptr: *mut uci_ptr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_del_list: Remove a string from an element list"]
    #[doc = " @ctx: uci context"]
    #[doc = " @ptr: uci pointer (with value)"]
    #[doc = ""]
    pub fn uci_del_list(ctx: *mut uci_context, ptr: *mut uci_ptr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_reorder: Reposition a section"]
    #[doc = " @ctx: uci context"]
    #[doc = " @s: uci section to reposition"]
    #[doc = " @pos: new position in the section list"]
    pub fn uci_reorder_section(
        ctx: *mut uci_context,
        s: *mut uci_section,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_rename: Rename an element"]
    #[doc = " @ctx: uci context"]
    #[doc = " @ptr: uci pointer (with value)"]
    pub fn uci_rename(ctx: *mut uci_context, ptr: *mut uci_ptr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_delete: Delete a section or option"]
    #[doc = " @ctx: uci context"]
    #[doc = " @ptr: uci pointer"]
    pub fn uci_delete(ctx: *mut uci_context, ptr: *mut uci_ptr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_save: save change delta for a package"]
    #[doc = " @ctx: uci context"]
    #[doc = " @p: uci_package struct"]
    pub fn uci_save(ctx: *mut uci_context, p: *mut uci_package) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_commit: commit changes to a package"]
    #[doc = " @ctx: uci context"]
    #[doc = " @p: uci_package struct pointer"]
    #[doc = " @overwrite: overwrite existing config data and flush delta"]
    #[doc = ""]
    #[doc = " committing may reload the whole uci_package data,"]
    #[doc = " the supplied pointer is updated accordingly"]
    pub fn uci_commit(
        ctx: *mut uci_context,
        p: *mut *mut uci_package,
        overwrite: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_list_configs: List available uci config files"]
    #[doc = " @ctx: uci context"]
    #[doc = ""]
    #[doc = " caller is responsible for freeing the allocated memory behind list"]
    pub fn uci_list_configs(
        ctx: *mut uci_context,
        list: *mut *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_set_savedir: override the default delta save directory"]
    #[doc = " @ctx: uci context"]
    #[doc = " @dir: directory name"]
    #[doc = ""]
    #[doc = " This will also try adding the specified dir to the end of delta pathes."]
    pub fn uci_set_savedir(
        ctx: *mut uci_context,
        dir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_set_savedir: override the default config storage directory"]
    #[doc = " @ctx: uci context"]
    #[doc = " @dir: directory name"]
    pub fn uci_set_confdir(
        ctx: *mut uci_context,
        dir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_add_delta_path: add a directory to the search path for change delta files"]
    #[doc = " @ctx: uci context"]
    #[doc = " @dir: directory name"]
    #[doc = ""]
    #[doc = " This function allows you to add directories, which contain 'overlays'"]
    #[doc = " for the active config, that will never be committed."]
    #[doc = ""]
    #[doc = " Adding a duplicate directory will cause UCI_ERR_DUPLICATE be returned."]
    pub fn uci_add_delta_path(
        ctx: *mut uci_context,
        dir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_revert: revert all changes to a config item"]
    #[doc = " @ctx: uci context"]
    #[doc = " @ptr: uci pointer"]
    pub fn uci_revert(ctx: *mut uci_context, ptr: *mut uci_ptr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_parse_argument: parse a shell-style argument, with an arbitrary quoting style"]
    #[doc = " @ctx: uci context"]
    #[doc = " @stream: input stream"]
    #[doc = " @str: pointer to the current line (use NULL for parsing the next line)"]
    #[doc = " @result: pointer for the result"]
    pub fn uci_parse_argument(
        ctx: *mut uci_context,
        stream: *mut FILE,
        str_: *mut *mut ::std::os::raw::c_char,
        result: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_set_backend: change the default backend"]
    #[doc = " @ctx: uci context"]
    #[doc = " @name: name of the backend"]
    #[doc = ""]
    #[doc = " The default backend is \"file\", which uses /etc/config for config storage"]
    pub fn uci_set_backend(
        ctx: *mut uci_context,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_validate_text: validate a value string for uci options"]
    #[doc = " @str: value"]
    #[doc = ""]
    #[doc = " this function checks whether a given string is acceptable as value"]
    #[doc = " for uci options"]
    pub fn uci_validate_text(str_: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " uci_parse_ptr: parse a uci string into a uci_ptr"]
    #[doc = " @ctx: uci context"]
    #[doc = " @ptr: target data structure"]
    #[doc = " @str: string to parse"]
    #[doc = ""]
    #[doc = " str is modified by this function"]
    pub fn uci_parse_ptr(
        ctx: *mut uci_context,
        ptr: *mut uci_ptr,
        str_: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_lookup_next: lookup a child element"]
    #[doc = " @ctx: uci context"]
    #[doc = " @e: target element pointer"]
    #[doc = " @list: list of elements"]
    #[doc = " @name: name of the child element"]
    #[doc = ""]
    #[doc = " if parent is NULL, the function looks up the package with the given name"]
    pub fn uci_lookup_next(
        ctx: *mut uci_context,
        e: *mut *mut uci_element,
        list: *mut uci_list,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " uci_parse_section: look up a set of options"]
    #[doc = " @s: uci section"]
    #[doc = " @opts: list of options to look up"]
    #[doc = " @n_opts: number of options to look up"]
    #[doc = " @tb: array of pointers to found options"]
    pub fn uci_parse_section(
        s: *mut uci_section,
        opts: *const uci_parse_option,
        n_opts: ::std::os::raw::c_int,
        tb: *mut *mut uci_option,
    );
}
extern "C" {
    #[doc = " uci_hash_options: build a hash over a list of options"]
    #[doc = " @tb: list of option pointers"]
    #[doc = " @n_opts: number of options"]
    pub fn uci_hash_options(tb: *mut *mut uci_option, n_opts: ::std::os::raw::c_int) -> u32;
}
pub const uci_type_UCI_TYPE_UNSPEC: uci_type = 0;
pub const uci_type_UCI_TYPE_DELTA: uci_type = 1;
pub const uci_type_UCI_TYPE_PACKAGE: uci_type = 2;
pub const uci_type_UCI_TYPE_SECTION: uci_type = 3;
pub const uci_type_UCI_TYPE_OPTION: uci_type = 4;
pub const uci_type_UCI_TYPE_PATH: uci_type = 5;
pub const uci_type_UCI_TYPE_BACKEND: uci_type = 6;
pub const uci_type_UCI_TYPE_ITEM: uci_type = 7;
pub const uci_type_UCI_TYPE_HOOK: uci_type = 8;
pub type uci_type = ::std::os::raw::c_uint;
pub const uci_option_type_UCI_TYPE_STRING: uci_option_type = 0;
pub const uci_option_type_UCI_TYPE_LIST: uci_option_type = 1;
pub type uci_option_type = ::std::os::raw::c_uint;
pub const uci_flags_UCI_FLAG_STRICT: uci_flags = 1;
pub const uci_flags_UCI_FLAG_PERROR: uci_flags = 2;
pub const uci_flags_UCI_FLAG_EXPORT_NAME: uci_flags = 4;
pub const uci_flags_UCI_FLAG_SAVED_DELTA: uci_flags = 8;
pub type uci_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uci_element {
    pub list: uci_list,
    pub type_: uci_type,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uci_element() {
    assert_eq!(
        ::std::mem::size_of::<uci_element>(),
        32usize,
        concat!("Size of: ", stringify!(uci_element))
    );
    assert_eq!(
        ::std::mem::align_of::<uci_element>(),
        8usize,
        concat!("Alignment of ", stringify!(uci_element))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_element>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_element),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_element>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_element),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_element>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_element),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uci_backend {
    pub e: uci_element,
    pub list_configs: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut uci_context) -> *mut *mut ::std::os::raw::c_char,
    >,
    pub load: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut uci_context,
            name: *const ::std::os::raw::c_char,
        ) -> *mut uci_package,
    >,
    pub commit: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut uci_context, p: *mut *mut uci_package, overwrite: bool),
    >,
    pub ptr: *const ::std::os::raw::c_void,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_uci_backend() {
    assert_eq!(
        ::std::mem::size_of::<uci_backend>(),
        72usize,
        concat!("Size of: ", stringify!(uci_backend))
    );
    assert_eq!(
        ::std::mem::align_of::<uci_backend>(),
        8usize,
        concat!("Alignment of ", stringify!(uci_backend))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_backend>())).e as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_backend),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_backend>())).list_configs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_backend),
            "::",
            stringify!(list_configs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_backend>())).load as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_backend),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_backend>())).commit as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_backend),
            "::",
            stringify!(commit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_backend>())).ptr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_backend),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_backend>())).priv_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_backend),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uci_context {
    pub root: uci_list,
    pub pctx: *mut uci_parse_context,
    pub backend: *mut uci_backend,
    pub backends: uci_list,
    pub flags: uci_flags,
    pub confdir: *mut ::std::os::raw::c_char,
    pub savedir: *mut ::std::os::raw::c_char,
    pub delta_path: uci_list,
    pub err: ::std::os::raw::c_int,
    pub func: *const ::std::os::raw::c_char,
    pub trap: jmp_buf,
    pub internal: bool,
    pub nested: bool,
    pub buf: *mut ::std::os::raw::c_char,
    pub bufsz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uci_context() {
    assert_eq!(
        ::std::mem::size_of::<uci_context>(),
        328usize,
        concat!("Size of: ", stringify!(uci_context))
    );
    assert_eq!(
        ::std::mem::align_of::<uci_context>(),
        8usize,
        concat!("Alignment of ", stringify!(uci_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).pctx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(pctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).backend as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(backend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).backends as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(backends)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).confdir as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(confdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).savedir as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(savedir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).delta_path as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(delta_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).err as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).func as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).trap as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(trap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).internal as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).nested as *const _ as usize },
        305usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(nested)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).buf as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_context>())).bufsz as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_context),
            "::",
            stringify!(bufsz)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uci_package {
    pub e: uci_element,
    pub sections: uci_list,
    pub ctx: *mut uci_context,
    pub has_delta: bool,
    pub path: *mut ::std::os::raw::c_char,
    pub backend: *mut uci_backend,
    pub priv_: *mut ::std::os::raw::c_void,
    pub n_section: ::std::os::raw::c_int,
    pub delta: uci_list,
    pub saved_delta: uci_list,
}
#[test]
fn bindgen_test_layout_uci_package() {
    assert_eq!(
        ::std::mem::size_of::<uci_package>(),
        128usize,
        concat!("Size of: ", stringify!(uci_package))
    );
    assert_eq!(
        ::std::mem::align_of::<uci_package>(),
        8usize,
        concat!("Alignment of ", stringify!(uci_package))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_package>())).e as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_package),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_package>())).sections as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_package),
            "::",
            stringify!(sections)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_package>())).ctx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_package),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_package>())).has_delta as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_package),
            "::",
            stringify!(has_delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_package>())).path as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_package),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_package>())).backend as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_package),
            "::",
            stringify!(backend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_package>())).priv_ as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_package),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_package>())).n_section as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_package),
            "::",
            stringify!(n_section)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_package>())).delta as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_package),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_package>())).saved_delta as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_package),
            "::",
            stringify!(saved_delta)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uci_section {
    pub e: uci_element,
    pub options: uci_list,
    pub package: *mut uci_package,
    pub anonymous: bool,
    pub type_: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uci_section() {
    assert_eq!(
        ::std::mem::size_of::<uci_section>(),
        72usize,
        concat!("Size of: ", stringify!(uci_section))
    );
    assert_eq!(
        ::std::mem::align_of::<uci_section>(),
        8usize,
        concat!("Alignment of ", stringify!(uci_section))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_section>())).e as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_section),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_section>())).options as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_section),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_section>())).package as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_section),
            "::",
            stringify!(package)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_section>())).anonymous as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_section),
            "::",
            stringify!(anonymous)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_section>())).type_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_section),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uci_option {
    pub e: uci_element,
    pub section: *mut uci_section,
    pub type_: uci_option_type,
    pub v: uci_option__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uci_option__bindgen_ty_1 {
    pub list: uci_list,
    pub string: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uci_option__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uci_option__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(uci_option__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uci_option__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uci_option__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_option__bindgen_ty_1>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_option__bindgen_ty_1),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_option__bindgen_ty_1>())).string as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_option__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
}
#[test]
fn bindgen_test_layout_uci_option() {
    assert_eq!(
        ::std::mem::size_of::<uci_option>(),
        64usize,
        concat!("Size of: ", stringify!(uci_option))
    );
    assert_eq!(
        ::std::mem::align_of::<uci_option>(),
        8usize,
        concat!("Alignment of ", stringify!(uci_option))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_option>())).e as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_option),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_option>())).section as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_option),
            "::",
            stringify!(section)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_option>())).type_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_option),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_option>())).v as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_option),
            "::",
            stringify!(v)
        )
    );
}
pub const uci_command_UCI_CMD_ADD: uci_command = 0;
pub const uci_command_UCI_CMD_REMOVE: uci_command = 1;
pub const uci_command_UCI_CMD_CHANGE: uci_command = 2;
pub const uci_command_UCI_CMD_RENAME: uci_command = 3;
pub const uci_command_UCI_CMD_REORDER: uci_command = 4;
pub const uci_command_UCI_CMD_LIST_ADD: uci_command = 5;
pub const uci_command_UCI_CMD_LIST_DEL: uci_command = 6;
pub const uci_command___UCI_CMD_MAX: uci_command = 7;
pub const uci_command___UCI_CMD_LAST: uci_command = 6;
pub type uci_command = ::std::os::raw::c_uint;
extern "C" {
    pub static mut uci_command_char: [::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uci_delta {
    pub e: uci_element,
    pub cmd: uci_command,
    pub section: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uci_delta() {
    assert_eq!(
        ::std::mem::size_of::<uci_delta>(),
        56usize,
        concat!("Size of: ", stringify!(uci_delta))
    );
    assert_eq!(
        ::std::mem::align_of::<uci_delta>(),
        8usize,
        concat!("Alignment of ", stringify!(uci_delta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_delta>())).e as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_delta),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_delta>())).cmd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_delta),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_delta>())).section as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_delta),
            "::",
            stringify!(section)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_delta>())).value as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_delta),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uci_ptr {
    pub target: uci_type,
    pub flags: uci_ptr__bindgen_ty_1,
    pub p: *mut uci_package,
    pub s: *mut uci_section,
    pub o: *mut uci_option,
    pub last: *mut uci_element,
    pub package: *const ::std::os::raw::c_char,
    pub section: *const ::std::os::raw::c_char,
    pub option: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
pub const uci_ptr_UCI_LOOKUP_DONE: ::std::os::raw::c_uint = 1;
pub const uci_ptr_UCI_LOOKUP_COMPLETE: ::std::os::raw::c_uint = 2;
pub const uci_ptr_UCI_LOOKUP_EXTENDED: ::std::os::raw::c_uint = 4;
pub type uci_ptr__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_uci_ptr() {
    assert_eq!(
        ::std::mem::size_of::<uci_ptr>(),
        72usize,
        concat!("Size of: ", stringify!(uci_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<uci_ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(uci_ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_ptr>())).target as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_ptr),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_ptr>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_ptr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_ptr>())).p as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_ptr),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_ptr>())).s as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_ptr),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_ptr>())).o as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_ptr),
            "::",
            stringify!(o)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_ptr>())).last as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_ptr),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_ptr>())).package as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_ptr),
            "::",
            stringify!(package)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_ptr>())).section as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_ptr),
            "::",
            stringify!(section)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_ptr>())).option as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_ptr),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_ptr>())).value as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_ptr),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uci_parse_option {
    pub name: *const ::std::os::raw::c_char,
    pub type_: uci_option_type,
}
#[test]
fn bindgen_test_layout_uci_parse_option() {
    assert_eq!(
        ::std::mem::size_of::<uci_parse_option>(),
        16usize,
        concat!("Size of: ", stringify!(uci_parse_option))
    );
    assert_eq!(
        ::std::mem::align_of::<uci_parse_option>(),
        8usize,
        concat!("Alignment of ", stringify!(uci_parse_option))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_parse_option>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_parse_option),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uci_parse_option>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uci_parse_option),
            "::",
            stringify!(type_)
        )
    );
}
